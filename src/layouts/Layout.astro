---
interface Props {
	title: string;
}
const { title } = Astro.props;
import './reset.css'
import "./animations.css";
import './fonts.css'
import "./layout.css";
---

<!doctype html>
<html lang="en">
	<head>
		<meta charset="UTF-8" />
		<meta name="viewport" content="width=device-width" />
		<link rel="icon" type="image/svg+xml" href="https://hrtowii.github.io/img/oneshotsun.png" />
		<script
			src="https://kit.fontawesome.com/e23a98c840.js"
			crossorigin="anonymous"></script>
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?family=Sora:wght@100..800&display=swap"
			rel="stylesheet"
		/>
		<link
			rel="stylesheet"
			href="https://cdn.jsdelivr.net/npm/galmuri/dist/galmuri.css"
		/>
		<slot name="metadata" />
		<title>{title}</title>
	</head>
	<body>
		<script src="./oneko.js"></script>
		<canvas id="rainCanvas"></canvas>
		<div class="container">
			<slot />
		</div>
	</body>
</html>
<script>
	// @ts-nocheck
	// Helper functions for cookies
	function getCookie(name) {
		const value = `; ${document.cookie}`;
		const parts = value.split(`; ${name}=`);
		if (parts.length === 2) return parts.pop().split(";").shift();
		return null;
	}

	function setCookie(name, value) {
		document.cookie = `${name}=${value}; path=/; max-age=31536000`; // 1 year
	}

	// =======================================
	// >> RAIN SYSTEM
	// =======================================

	class RainDrop {
		constructor(canvas, x, y, speedMultiplier = 1) {
			this.canvas = canvas;
			this.x = x;
			this.y = y;
			this.baseSpeed = 15 + Math.random() * 5;
			this.speedMultiplier = speedMultiplier;
			this.speed = this.baseSpeed * this.speedMultiplier;
			this.length = 15 + Math.random() * 5;
			this.width = 1 + Math.random();
			this.bounced = false;
			this.isDead = false;
		}

		setSpeedMultiplier(multiplier) {
			this.speedMultiplier = multiplier;
			this.speed = this.baseSpeed * this.speedMultiplier;
		}

		update(containerTop) {
			this.y += this.speed;

			const container = document.querySelector(".container");
			const containerRect = container.getBoundingClientRect();
			const isOverContainer =
				this.x >= containerRect.left && this.x <= containerRect.right;

			if (isOverContainer && !this.bounced && this.y > containerTop) {
				this.bounced = true;
				this.speed = -this.speed * 0.3;
				return true;
			}

			if (!isOverContainer && this.y > this.canvas.height) {
				this.isDead = true;
				return false;
			}

			if (this.bounced) {
				this.speed += 0.8;
				if (Math.abs(this.speed) < 0.5) {
					this.isDead = true;
					return false;
				}
			}

			return false;
		}

		draw(ctx) {
			ctx.beginPath();
			ctx.strokeStyle = "rgba(174, 194, 224, 0.5)";
			ctx.lineWidth = this.width;
			ctx.moveTo(this.x, this.y);
			ctx.lineTo(this.x, this.y + this.length);
			ctx.stroke();
		}
	}

	class RainSystem {
		constructor() {
			this.isAnimating = false;
			this.canvas = document.getElementById("rainCanvas");
			this.ctx = this.canvas.getContext("2d");
			this.drops = [];
			this.splashes = [];
			this.speedMultiplier = 3;
			this.resizeCanvas();
			this.container = document.querySelector(".container");
			this.containerTop = this.container.getBoundingClientRect().top;

			window.addEventListener("resize", () => this.resizeCanvas());

			window.addEventListener("scroll", () =>
				this.updateContainerPosition(),
			);
			window.addEventListener("resize", () => {
				this.resizeCanvas();
				this.updateContainerPosition();
			});

			this.resizeObserver = new ResizeObserver(() => {
				this.updateContainerPosition();
			});
			this.resizeObserver.observe(this.container);
		}

		setSpeedMultiplier(multiplier) {
			this.speedMultiplier = multiplier;
			this.drops.forEach((drop) => drop.setSpeedMultiplier(multiplier));
		}

		updateContainerPosition() {
			const oldTop = this.containerTop;
			this.containerTop = this.container.getBoundingClientRect().top;

			const diff = this.containerTop - oldTop;
			this.splashes.forEach((particles) => {
				particles.forEach((p) => {
					p.y += diff;
				});
			});
		}

		resizeCanvas() {
			this.canvas.width = window.innerWidth;
			this.canvas.height = window.innerHeight;
		}

		createDrop() {
			const x = Math.random() * this.canvas.width;
			const y = -20;
			// Pass current speed multiplier to new drops
			this.drops.push(
				new RainDrop(this.canvas, x, y, this.speedMultiplier),
			);
		}

		createSplash(x, y) {
			const particleCount = 3 + Math.floor(Math.random() * 3);
			const particles = [];

			for (let i = 0; i < particleCount; i++) {
				const angle = Math.PI / 4 + (Math.random() * Math.PI) / 2;
				const speed = 1 + Math.random() * 2;
				particles.push({
					x: x,
					y: y,
					vx: Math.cos(angle) * speed,
					vy: -Math.sin(angle) * speed,
					alpha: 1,
				});
			}

			this.splashes.push(particles);
		}

		update() {
			if (Math.random() < 0.5) {
				this.createDrop();
			}

			this.drops = this.drops.filter((drop) => {
				const shouldCreateSplash = drop.update(this.containerTop);
				if (shouldCreateSplash) {
					this.createSplash(drop.x, drop.y);
				}
				return !drop.isDead;
			});

			this.splashes = this.splashes.filter((particles) => {
				particles.forEach((p) => {
					p.x += p.vx;
					p.y += p.vy;
					p.vy += 0.1;
					p.alpha -= 0.03;
				});
				return particles.some((p) => p.alpha > 0);
			});
		}

		draw() {
			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

			this.drops.forEach((drop) => drop.draw(this.ctx));

			this.splashes.forEach((particles) => {
				particles.forEach((p) => {
					this.ctx.beginPath();
					this.ctx.strokeStyle = `rgba(174, 194, 224, ${p.alpha})`;
					this.ctx.lineWidth = 1;
					this.ctx.moveTo(p.x, p.y);
					this.ctx.lineTo(p.x + p.vx, p.y + p.vy);
					this.ctx.stroke();
				});
			});
		}

		animate() {
			if (!this.isAnimating) return;

			this.update();
			this.draw();
			requestAnimationFrame(() => this.animate());
		}

		start() {
			this.isAnimating = true;
			this.animate();
		}

		stop() {
			this.isAnimating = false;
			this.drops = [];
			this.splashes = [];
			this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
		}
	}

	// =======================================
	// >> WEATHER MANAGEMENT SYSTEM
	// =======================================

	class WeatherManager {
		constructor() {
			this.rainSystem = null;
			this.isFirstVisit = !getCookie("weatherPreferencesSet");
			this.speedMultiplier = parseFloat(
				getCookie("weatherSpeed") || "1.0",
			);
			this.initializeSystems();
			this.initializeUI();
			this.loadSettings();
		}
		initializeSystems() {
			this.rainSystem = new RainSystem();
		}
		async loadSettings() {
			if (this.isFirstVisit) {
				setCookie("rainEnabled", "true");
				setCookie("weatherSpeed", "1.0");
				setCookie("weatherPreferencesSet", "true");
				const rainToggle = document.getElementById("rainToggle");
				const speedSlider = document.getElementById("weatherSpeed");
				const speedValue = document.getElementById("speedValue");
				if (rainToggle) rainToggle.checked = true;
				if (speedSlider) speedSlider.value = 1.0;
				if (speedValue) speedValue.textContent = "1.0x";
				this.rainSystem.start();
				return;
			}
			const rainEnabled = getCookie("rainEnabled") === "true";
			const speed = parseFloat(getCookie("weatherSpeed") || "11.0");
			const rainToggle = document.getElementById("rainToggle");
			const speedSlider = document.getElementById("weatherSpeed");
			const speedValue = document.getElementById("speedValue");
			if (rainToggle) rainToggle.checked = rainEnabled;
			if (speedSlider) speedSlider.value = speed;
			if (speedValue) speedValue.textContent = speed + "x";
			this.rainSystem.stop();
			if (rainEnabled) {
				this.rainSystem.start();
			}
			this.updateSpeed(speed);
		}

		initializeUI() {
			const weatherSettings = document.querySelector(".site-settings");
			const tab = document.querySelector(".settings-tab");

			if (tab) {
				tab.addEventListener("click", (e) => {
					e.stopPropagation();
					if (weatherSettings)
						weatherSettings.classList.toggle("open");
				});
			}

			document.addEventListener("click", (e) => {
				if (weatherSettings && e.target && !weatherSettings.contains(e.target)) {
					weatherSettings.classList.remove("open");
				}
			});

			const rainToggle = document.getElementById("rainToggle");

			if (rainToggle) {
				rainToggle.addEventListener("click", (e) =>
					e.stopPropagation(),
				);
				rainToggle.addEventListener("change", () =>
					this.toggleRain(rainToggle.checked),
				);
			}

			const speedSlider = document.getElementById("weatherSpeed");
			if (speedSlider) {
				speedSlider.min = "0.2";
				speedSlider.max = "3.0";
				speedSlider.step = "0.1";
				speedSlider.value = "3.0";

				const speedValue = document.getElementById("speedValue");

				speedSlider.addEventListener("input", (e) => {
					const speed = parseFloat(e.target.value);
					if (speedValue) speedValue.textContent = speed + "x";
					this.updateSpeed(speed);
				});
			}

			const disableButton = document.getElementById("disableWeather");
			if (disableButton) {
				disableButton.addEventListener("click", () => {
					const rainToggle = document.getElementById("rainToggle");

					if (rainToggle) rainToggle.checked = false;

					this.toggleRain(false);
				});
			}
		}

		updateSpeed(multiplier) {
			this.speedMultiplier = multiplier;
			setCookie("weatherSpeed", multiplier);

			if (this.rainSystem) {
				this.rainSystem.setSpeedMultiplier(multiplier);
			}
		}

		toggleRain(enabled) {
			if (enabled) {
				this.rainSystem.start();
			} else {
				this.rainSystem.stop();
			}
			setCookie("rainEnabled", enabled.toString());
		}
	}

	// =======================================
	// >> CRT FILTER MANAGEMENT
	// =======================================

	class CRTManager {
		constructor() {
			this.isLightMode = false;
			this.crtEnabled = true;
			this.initializeSettings();
			this.setupMediaQuery();
		}

		initializeSettings() {
			const savedCrtEnabled = getCookie("crtEnabled");
			if (savedCrtEnabled !== null) {
				this.crtEnabled = savedCrtEnabled === "true";
			} else {
				setCookie("crtEnabled", "true");
			}
			this.updateCRTFilter();
		}

		setupMediaQuery() {
			const mediaQuery = window.matchMedia("(prefers-color-scheme: light)");
			this.isLightMode = mediaQuery.matches;

			// Update on media query change
			mediaQuery.addEventListener("change", (e) => {
				this.isLightMode = e.matches;
				this.updateCRTFilter();
			});
		}

		updateCRTFilter() {
			const body = document.body;

			if (this.isLightMode || !this.crtEnabled) {
				body.classList.remove("crt-filter");
			} else {
				body.classList.add("crt-filter");
			}
		}

		setCRTEnabled(enabled) {
			this.crtEnabled = enabled;
			setCookie("crtEnabled", enabled.toString());
			this.updateCRTFilter();
		}
	}

	document.addEventListener("DOMContentLoaded", () => {
		window.weatherManager = new WeatherManager();
		window.crtManager = new CRTManager();
	});
</script>
